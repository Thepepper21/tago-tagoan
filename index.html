<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NULLMAZE</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=VT323&display=swap");

      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        color: #00ffff;
        font-family: "VT323", monospace;
        cursor: pointer;
      }

      canvas {
        display: block;
      }
 q
      #ui-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: center;
      }

      #crosshair {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 4px;
        height: 4px;
        background-color: rgba(255, 255, 255, 0.5);
        border-radius: 50%;
        transform: translate(-50%, -50%);
      }

      #objective {
        position: absolute;
        bottom: 20px;
        left: 20px;
        font-size: 2em;
        text-shadow: 0 0 5px #00ffff;
      }

      #blocker {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        text-align: center;
      }

      #instructions {
        width: 60%;
        font-size: 1.5em;
        letter-spacing: 1px;
      }
      #instructions span {
        font-size: 2.5em;
        text-shadow: 0 0 10px #ff0000;
      }

      .game-over-screen {
        display: none;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #000;
        justify-content: center;
        align-items: center;
        text-align: center;
        font-size: 2em;
        z-index: 100;
        animation: fadeIn 1s forwards;
      }

      .game-over-text {
        animation: glitch 1.5s linear infinite;
      }

      .game-over-text p {
        margin: 10px;
        color: #ff0000;
        text-shadow: 0 0 8px #ff0000;
      }
      .game-over-text small {
        font-size: 0.7em;
        color: #fff;
        text-shadow: none;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      @keyframes glitch {
        2%,
        64% {
          transform: translate(2px, 0) skew(0deg);
        }
        4%,
        60% {
          transform: translate(-2px, 0) skew(0deg);
        }
        62% {
          transform: translate(0, 0) skew(5deg);
        }
      }
    </style>
  </head>
  <body>
    <div id="blocker">
      <div id="instructions">
        <span>NULLMAZE</span>
        <br /><br />
        Find and activate the 5 Terminals to escape.
        <br />
        Do not let it find you.
        <br /><br />
        WASD: Move<br />
        SHIFT: Sprint (makes noise)<br />
        MOUSE: Look<br /><br />
        Click to Begin
      </div>
    </div>

    <div id="ui-container">
      <div id="crosshair"></div>
      <div id="objective">TERMINALS ACTIVATED: 0/5</div>
    </div>

    <div id="game-over" class="game-over-screen">
      <div class="game-over-text">
        <p>> CONNECTION TERMINATED.</p>
        <p>> REASON: SUBJECT APPREHENDED.</p>
        <br />
        <small>> [R] TO REINITIALIZE SIMULATION</small>
      </div>
    </div>

    <script
      async
      src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"
    ></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { PointerLockControls } from "three/addons/controls/PointerLockControls.js";

      // --- SCENE SETUP ---
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);
      scene.fog = new THREE.FogExp2(0x000011, 0.05);

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.y = 1.8; // Player height

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      // --- LIGHTING ---
      const ambientLight = new THREE.AmbientLight(0xaaaaaa, 1.5); // Much brighter ambient light
      scene.add(ambientLight);

      // Add some point lights for better visibility
      const light1 = new THREE.PointLight(0x00ddff, 1.2, 30);
      light1.position.set(20, 10, 20);
      scene.add(light1);

      const light2 = new THREE.PointLight(0xffcc00, 0.8, 35);
      light2.position.set(-20, 15, -20);
      scene.add(light2);

      const light3 = new THREE.PointLight(0xff00ff, 0.6, 25);
      light3.position.set(0, 12, 0);
      scene.add(light3);

      // Adjust fog for better visibility
      scene.fog = new THREE.FogExp2(0x1a1a2e, 0.02);

      // --- CONTROLS ---
      const controls = new PointerLockControls(camera, document.body);
      const blocker = document.getElementById("blocker");
      const instructions = document.getElementById("instructions");

      instructions.addEventListener("click", () => controls.lock());
      controls.addEventListener("lock", () => {
        instructions.style.display = "none";
        blocker.style.display = "none";
      });
      controls.addEventListener("unlock", () => {
        blocker.style.display = "block";
        instructions.style.display = "";
      });
      scene.add(controls.getObject());

      // --- PLAYER VARIABLES ---
      const playerVelocity = new THREE.Vector3();
      const playerDirection = new THREE.Vector3();
      const playerSpeed = 4.0;
      const playerSprintSpeed = 7.0;
      let isSprinting = false;
      let moveForward = false;
      let moveBackward = false;
      let moveLeft = false;
      let moveRight = false;
      const playerCollider = new THREE.Box3(
        new THREE.Vector3(),
        new THREE.Vector3()
      );
      playerCollider.setFromCenterAndSize(
        camera.position,
        new THREE.Vector3(0.5, 1.8, 0.5)
      );

      // --- KEYBOARD INPUT ---
      document.addEventListener("keydown", (event) => {
        switch (event.code) {
          case "ArrowUp":
          case "KeyW":
            moveForward = true;
            break;
          case "ArrowLeft":
          case "KeyA":
            moveLeft = true;
            break;
          case "ArrowDown":
          case "KeyS":
            moveBackward = true;
            break;
          case "ArrowRight":
          case "KeyD":
            moveRight = true;
            break;
          case "ShiftLeft":
            isSprinting = true;
            soundFootsteps.setPlaybackRate(1.5);
            break;
          case "KeyR":
            if (isGameOver) location.reload();
            break;
        }
      });

      document.addEventListener("keyup", (event) => {
        switch (event.code) {
          case "ArrowUp":
          case "KeyW":
            moveForward = false;
            break;
          case "ArrowLeft":
          case "KeyA":
            moveLeft = false;
            break;
          case "ArrowDown":
          case "KeyS":
            moveBackward = false;
            break;
          case "ArrowRight":
          case "KeyD":
            moveRight = false;
            break;
          case "ShiftLeft":
            isSprinting = false;
            soundFootsteps.setPlaybackRate(1.0);
            break;
        }
      });

      // --- MAZE GENERATION ---
      const maze = [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, "T", 1],
        [1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1],
        [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1],
        [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, "T", 0, 1, 0, 0, 0, 1, 0, 1],
        [1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
        [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, "T", 1, 1, 1, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, "T", 1, "P", 0, 0, 1],
        [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1],
        [1, "T", 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      ];

      const wallSize = 4;
      const wallHeight = 5;
      const wallMaterial = new THREE.MeshStandardMaterial({
        color: 0x8888aa,
        roughness: 0.7,
        metalness: 0.3,
      });
      const floorMaterial = new THREE.MeshStandardMaterial({
        color: 0x556677,
        roughness: 0.8,
        metalness: 0.2,
      });
      const walls = new THREE.Group();
      const terminals = [];
      const terminalSize = 0.5;

      const floor = new THREE.Mesh(
        new THREE.BoxGeometry(
          maze[0].length * wallSize,
          0.2,
          maze.length * wallSize
        ),
        floorMaterial
      );
      floor.position.y = -0.1;
      floor.receiveShadow = true;
      scene.add(floor);

      const ceiling = new THREE.Mesh(
        new THREE.BoxGeometry(
          maze[0].length * wallSize,
          0.2,
          maze.length * wallSize
        ),
        floorMaterial
      );
      ceiling.position.y = wallHeight;
      scene.add(ceiling);

      maze.forEach((row, z) => {
        row.forEach((cell, x) => {
          const posX = (x - Math.floor(row.length / 2)) * wallSize;
          const posZ = (z - Math.floor(maze.length / 2)) * wallSize;

          if (cell === 1) {
            const wall = new THREE.Mesh(
              new THREE.BoxGeometry(wallSize, wallHeight, wallSize),
              wallMaterial
            );
            wall.position.set(posX, wallHeight / 2, posZ);
            wall.castShadow = true;
            wall.receiveShadow = true;
            walls.add(wall);
          } else if (cell === "T") {
            const terminalGeo = new THREE.BoxGeometry(
              terminalSize,
              terminalSize,
              terminalSize
            );
            const terminalMat = new THREE.MeshBasicMaterial({
              color: 0x00ffff,
            });
            const terminal = new THREE.Mesh(terminalGeo, terminalMat);
            terminal.position.set(posX, wallHeight / 2, posZ);

            const terminalLight = new THREE.PointLight(0x00ffff, 2, 5);
            terminalLight.position.copy(terminal.position);
            scene.add(terminalLight);

            terminal.userData = { activated: false, light: terminalLight };
            terminals.push(terminal);
            scene.add(terminal);
          } else if (cell === "P") {
            controls.getObject().position.set(posX, 1.8, posZ);
          }
        });
      });
      scene.add(walls);

      // --- THE WARDEN (AI Hunter) ---
      const wardenGeo = new THREE.CapsuleGeometry(0.4, 2.5, 4, 16);
      const wardenMat = new THREE.MeshStandardMaterial({
        color: 0xff0000,
        emissive: 0xff0000,
        emissiveIntensity: 0.8,
        roughness: 0.2,
        metalness: 0.5,
      });
      const warden = new THREE.Mesh(wardenGeo, wardenMat);
      warden.castShadow = true;
      warden.position.set(0, 1.65, 0);

      const wardenSensor = new THREE.PointLight(0xff0000, 8, 20);
      wardenSensor.castShadow = true;
      wardenSensor.position.y = 1.0;
      warden.add(wardenSensor);

      // Add a bright spotlight on the warden for maximum visibility
      const wardenSpotlight = new THREE.SpotLight(0xff0000, 3, 30, Math.PI / 4);
      wardenSpotlight.position.set(0, 10, 0);
      wardenSpotlight.target = warden;
      scene.add(wardenSpotlight);
      scene.add(warden);

      let wardenState = "PATROL"; // PATROL, HUNT
      const wardenSpeed = 2.5;
      const wardenHuntSpeed = 5.0;
      const wardenPath = [
        new THREE.Vector3(-28, 1.65, -24),
        new THREE.Vector3(28, 1.65, -24),
        new THREE.Vector3(28, 1.65, 24),
        new THREE.Vector3(0, 1.65, 0),
        new THREE.Vector3(-28, 1.65, 24),
      ];
      let currentPathIndex = 0;
      warden.position.copy(wardenPath[0]);
      const wardenRaycaster = new THREE.Raycaster();

      // --- THE RUNNER (Additional Running Enemy) ---
      // Runner setup
      const runnerTexture = new THREE.TextureLoader().load('https://www.vhv.rs/dpng/d/485-4854988_running-sprite-sheet-png-graphic-transparent-stock-2d.png');
      runnerTexture.magFilter = THREE.NearestFilter;
      runnerTexture.minFilter = THREE.NearestFilter;
      const runnerMaterial = new THREE.MeshBasicMaterial({ 
        map: runnerTexture, 
        transparent: true, 
        side: THREE.DoubleSide 
      });
      const runnerGeo = new THREE.PlaneGeometry(2, 3);
      const runner = new THREE.Mesh(runnerGeo, runnerMaterial);
      scene.add(runner);
      runner.position.set(10, 1.5, 10);

      // Runner behavior variables
      let runnerState = "PATROL";
      const runnerSpeed = 1.5; // Reduced patrol speed
      const runnerHuntSpeed = 3.0; // Reduced hunt speed
      const runnerPath = [
        new THREE.Vector3(-10, 1.5, -10),
        new THREE.Vector3(10, 1.5, -10),
        new THREE.Vector3(10, 1.5, 10),
        new THREE.Vector3(-10, 1.5, 10),
      ];
      let currentPathIndexRunner = 0;
      runner.position.copy(runnerPath[0]);
      const runnerRaycaster = new THREE.Raycaster();
      let runnerFrame = 0;
      const numFrames = 8;
      const numRows = 1;
      let lastSightCheck = 0;
      const sightCheckInterval = 1.0; // Reduced sight check frequency
      let lastHuntTime = 0;
      const maxHuntDuration = 4.0; // Maximum time in seconds the runner will chase

      // Runner light effect
      const runnerSensor = new THREE.PointLight(0x00ffff, 3, 10);
      runnerSensor.castShadow = true;
      runnerSensor.position.y = 1.0;
      runner.add(runnerSensor);

      // --- SOUND DESIGN ---
      const listener = new THREE.AudioListener();
      camera.add(listener);

      const soundAmbiance = new THREE.Audio(listener);
      const soundHeartbeat = new THREE.Audio(listener);
      const soundStatic = new THREE.Audio(listener);
      const soundFootsteps = new THREE.PositionalAudio(listener);
      const soundTerminal = new THREE.PositionalAudio(listener);

      const audioLoader = new THREE.AudioLoader();

      // Using generated tones to avoid external files
      const createTone = (context, frequency, duration, type = "sine") => {
        const oscillator = context.createOscillator();
        const gainNode = context.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(context.destination);
        oscillator.type = type;
        oscillator.frequency.value = frequency;
        gainNode.gain.setValueAtTime(0, context.currentTime);
        gainNode.gain.linearRampToValueAtTime(0.5, context.currentTime + 0.01);
        gainNode.gain.linearRampToValueAtTime(
          0,
          context.currentTime + duration
        );
        oscillator.start(context.currentTime);
        oscillator.stop(context.currentTime + duration);
      };

      const playHeartbeat = () => {
        const context = listener.context;
        createTone(context, 80, 0.1, "sine");
        setTimeout(() => createTone(context, 80, 0.1, "sine"), 150);
      };

      // --- GAME LOGIC ---
      let isGameOver = false;
      let terminalsActivated = 0;
      const clock = new THREE.Clock();

      function updateWarden(delta) {
        const playerPos = controls.getObject().position;
        const wardenPos = warden.position;
        const distanceToPlayer = wardenPos.distanceTo(playerPos);

        // Raycast for line of sight
        wardenRaycaster.set(
          wardenPos,
          playerPos.clone().sub(wardenPos).normalize()
        );
        const intersects = wardenRaycaster.intersectObjects(
          walls.children,
          false
        );
        const hasLineOfSight =
          intersects.length === 0 || intersects[0].distance > distanceToPlayer;

        // State Transitions
        if (hasLineOfSight && distanceToPlayer < 20) {
          if (wardenState !== "HUNT") {
            // Play static sound on hunt start
            const context = listener.context;
            const bufferSize = context.sampleRate * 1; // 1 second of noise
            const buffer = context.createBuffer(
              1,
              bufferSize,
              context.sampleRate
            );
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
              data[i] = Math.random() * 2 - 1;
            }
            soundStatic.setBuffer(buffer);
            soundStatic.setVolume(0.3);
            soundStatic.play();
          }
          wardenState = "HUNT";
        } else if (distanceToPlayer > 25) {
          wardenState = "PATROL";
        }

        let target;
        let speed;

        // State Actions
        if (wardenState === "HUNT") {
          target = playerPos;
          speed = wardenHuntSpeed;
          wardenSensor.color.set(0xff0000);
          wardenSensor.intensity = 15;
          warden.material.emissive.set(0xff0000);
          warden.material.emissiveIntensity = 1.5;

          // Heartbeat effect
          const heartbeatSpeed =
            1.0 - THREE.MathUtils.clamp(distanceToPlayer / 20, 0, 1);
          const interval = 200 + (1 - heartbeatSpeed) * 800;
          if (!soundHeartbeat.isPlaying) {
            playHeartbeat();
            soundHeartbeat.source.buffer = null; // Hack to allow re-playing
            soundHeartbeat.play();
            setTimeout(() => {
              if (soundHeartbeat.isPlaying) soundHeartbeat.stop();
            }, interval);
          }
        } else {
          // PATROL
          target = wardenPath[currentPathIndex];
          speed = wardenSpeed;
          wardenSensor.color.set(0xffff00);
          wardenSensor.intensity = 8;
          warden.material.emissive.set(0xff6600);
          warden.material.emissiveIntensity = 0.6;

          if (wardenPos.distanceTo(target) < 1) {
            currentPathIndex = (currentPathIndex + 1) % wardenPath.length;
          }
        }

        warden.lookAt(target.x, warden.position.y, target.z);
        warden.position.add(
          warden
            .getWorldDirection(new THREE.Vector3())
            .multiplyScalar(speed * delta)
        );

        // Game Over Check
        if (distanceToPlayer < 1.5) {
          gameOver();
        }
      }

      function updateRunner(delta) {
        const playerPos = controls.getObject().position;
        const runnerPos = runner.position;
        const distanceToPlayer = runnerPos.distanceTo(playerPos);
        const now = Date.now() / 1000; // Current time in seconds

        // Only check line of sight periodically to reduce difficulty
        let hasLineOfSight = false;
        if (now - lastSightCheck > sightCheckInterval) {
          runnerRaycaster.set(
            runnerPos,
            playerPos.clone().sub(runnerPos).normalize()
          );
          const intersects = runnerRaycaster.intersectObjects(walls.children, false);
          hasLineOfSight = intersects.length === 0 || intersects[0].distance > distanceToPlayer;
          lastSightCheck = now;
        }

        // State Transitions
        if (runnerState === "PATROL") {
          if (hasLineOfSight && distanceToPlayer < 15) { // Reduced detection range
            runnerState = "HUNT";
            lastHuntTime = now;
          }
        } else { // HUNT state
          // Return to patrol if player escapes or max hunt time reached
          if (distanceToPlayer > 25 || now - lastHuntTime > maxHuntDuration) {
            runnerState = "PATROL";
          }
        }

        let target;
        let speed;
        let frameRate;

        // State Actions
        if (runnerState === "HUNT") {
          target = playerPos;
          speed = runnerHuntSpeed * (0.8 + Math.random() * 0.4); // Add some randomness to speed
          runnerSensor.color.set(0xff3333); // Softer red when hunting
          runnerSensor.intensity = 8;
          frameRate = 12; // Slightly slower animation when hunting
        } else {
          // PATROL
          target = runnerPath[currentPathIndexRunner];
          speed = runnerSpeed * (0.7 + Math.random() * 0.6); // More random patrol speed
          runnerSensor.color.set(0x00aaff); // Brighter blue when patrolling
          runnerSensor.intensity = 4;
          frameRate = 4 + Math.sin(now * 2) * 2; // Subtle animation variation

          if (runnerPos.distanceTo(target) < 2) {
            currentPathIndexRunner = (currentPathIndexRunner + 1) % runnerPath.length;
          }
        }

        // Smooth rotation towards target
        const targetDirection = new THREE.Vector3();
        targetDirection.subVectors(target, runnerPos).normalize();
        const targetQuaternion = new THREE.Quaternion().setFromUnitVectors(
          new THREE.Vector3(0, 0, -1), // Default forward direction
          new THREE.Vector3(targetDirection.x, 0, targetDirection.z).normalize()
        );
        runner.quaternion.slerp(targetQuaternion, 5.0 * delta);

        // Move runner
        const moveDirection = new THREE.Vector3(0, 0, -1)
          .applyQuaternion(runner.quaternion)
          .multiplyScalar(speed * delta);
        
        runner.position.add(moveDirection);

        // Animation
        runnerMaterial.map.repeat.set(1 / numFrames, 1 / numRows);
        runnerFrame += delta * frameRate;
        const currentFrame = Math.floor(runnerFrame) % numFrames;
        const row = 0;
        runnerMaterial.map.offset.set(
          currentFrame / numFrames,
          (numRows - 1 - row) / numRows
        );

        // Game Over Check - More forgiving collision
        if (distanceToPlayer < 2.0) {
          // Only trigger game over if facing the player
          const directionToPlayer = new THREE.Vector3()
            .subVectors(playerPos, runnerPos)
            .normalize();
          const dot = runner.getWorldDirection(new THREE.Vector3()).dot(directionToPlayer);
          
          if (dot > 0.5) { // Runner must be facing somewhat towards player
            gameOver();
          }
        }
      }

      function checkCollisions(delta) {
        const speed = isSprinting ? playerSprintSpeed : playerSpeed;
        playerVelocity.x -= playerVelocity.x * 10.0 * delta;
        playerVelocity.z -= playerVelocity.z * 10.0 * delta;

        playerDirection.z = Number(moveForward) - Number(moveBackward);
        playerDirection.x = Number(moveLeft) - Number(moveRight);
        playerDirection.normalize();

        if (moveForward || moveBackward)
          playerVelocity.z -= playerDirection.z * speed * delta * 10;
        if (moveLeft || moveRight)
          playerVelocity.x -= playerDirection.x * speed * delta * 10;

        const oldPosition = controls.getObject().position.clone();

        controls.moveRight(-playerVelocity.x * delta);
        controls.moveForward(-playerVelocity.z * delta);

        playerCollider.setFromCenterAndSize(
          controls.getObject().position,
          new THREE.Vector3(0.5, 1.8, 0.5)
        );

        walls.children.forEach((wall) => {
          const wallBox = new THREE.Box3().setFromObject(wall);
          if (playerCollider.intersectsBox(wallBox)) {
            controls.getObject().position.copy(oldPosition);
            playerVelocity.set(0, 0, 0);
          }
        });
      }

      function checkInteractions() {
        const playerPos = controls.getObject().position;
        terminals.forEach((terminal) => {
          if (
            !terminal.userData.activated &&
            playerPos.distanceTo(terminal.position) < 2
          ) {
            terminal.userData.activated = true;
            terminalsActivated++;
            document.getElementById(
              "objective"
            ).innerText = `TERMINALS ACTIVATED: ${terminalsActivated}/5`;

            // Terminal activation visual and sound effect
            terminal.material.color.set(0x00ff00);
            terminal.userData.light.color.set(0x00ff00);

            const context = listener.context;
            createTone(context, 880, 0.1, "square");
            setTimeout(() => createTone(context, 1046, 0.2, "square"), 100);

            if (terminalsActivated === 5) {
              winGame();
            }
          }
        });
      }

      function gameOver() {
        if (isGameOver) return;
        isGameOver = true;
        controls.unlock();
        document.getElementById("game-over").style.display = "flex";
      }

      function winGame() {
        isGameOver = true;
        controls.unlock();
        const winScreen = document.getElementById("game-over");
        const winText = winScreen.querySelector(".game-over-text");
        winText.innerHTML = `<p style="color: #00ff00; text-shadow: 0 0 8px #00ff00;">> SYSTEM BYPASSED.</p><p style="color: #00ff00; text-shadow: 0 0 8px #00ff00;">> ESCAPE PROTOCOL ENGAGED.</p><br/><small>> YOU ARE FREE.</small>`;
        winScreen.style.display = "flex";
      }

      // --- RENDER LOOP ---
      function animate() {
        if (isGameOver) return;

        requestAnimationFrame(animate);
        const delta = clock.getDelta();

        if (controls.isLocked === true) {
          checkCollisions(delta);
          checkInteractions();
          updateWarden(delta);
          updateRunner(delta);
        }

        renderer.render(scene, camera);
      }

      // --- START ---
      animate();

      // --- RESIZE ---
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>