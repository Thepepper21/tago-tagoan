<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NULLMAZE</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=VT323&display=swap");

      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        color: #00ffff;
        font-family: "VT323", monospace;
        cursor: pointer;
      }

      canvas {
        display: block;
      }

      #ui-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: center;
      }

      #crosshair {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 4px;
        height: 4px;
        background-color: rgba(255, 255, 255, 0.5);
        border-radius: 50%;
        transform: translate(-50%, -50%);
      }

      #objective {
        position: absolute;
        bottom: 20px;
        left: 20px;
        font-size: 2em;
        text-shadow: 0 0 5px #00ffff;
      }

      #blocker {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        text-align: center;
      }

      #instructions {
        width: 60%;
        font-size: 1.5em;
        letter-spacing: 1px;
      }
      #instructions span {
        font-size: 2.5em;
        text-shadow: 0 0 10px #ff0000;
      }

      .game-over-screen {
        display: none;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #000;
        justify-content: center;
        align-items: center;
        text-align: center;
        font-size: 2em;
        z-index: 100;
        animation: fadeIn 1s forwards;
      }

      .game-over-text {
        animation: glitch 1.5s linear infinite;
      }

      .game-over-text p {
        margin: 10px;
        color: #ff0000;
        text-shadow: 0 0 8px #ff0000;
      }
      .game-over-text small {
        font-size: 0.7em;
        color: #fff;
        text-shadow: none;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      @keyframes glitch {
        2%,
        64% {
          transform: translate(2px, 0) skew(0deg);
        }
        4%,
        60% {
          transform: translate(-2px, 0) skew(0deg);
        }
        62% {
          transform: translate(0, 0) skew(5deg);
        }
      }
    </style>
  </head>
  <body>
    <div id="blocker">
      <div id="instructions">
        <span>NULLMAZE</span>
        <br /><br />
        Find and activate the 5 Terminals to escape.
        <br />
        Do not let it find you.
        <br /><br />
        WASD: Move<br />
        SHIFT: Sprint (makes noise)<br />
        MOUSE: Look<br /><br />
        Click to Begin
      </div>
    </div>

    <div id="ui-container">
      <div id="crosshair"></div>
      <div id="objective">TERMINALS ACTIVATED: 0/5</div>
    </div>

    <div id="game-over" class="game-over-screen">
      <div class="game-over-text">
        <p>> CONNECTION TERMINATED.</p>
        <p>> REASON: SUBJECT APPREHENDED.</p>
        <br />
        <small>> [R] TO REINITIALIZE SIMULATION</small>
      </div>
    </div>

    <script
      async
      src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"
    ></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { PointerLockControls } from "three/addons/controls/PointerLockControls.js";

      // --- SCENE SETUP ---
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0a15);
      scene.fog = new THREE.FogExp2(0x0a0a15, 0.03);

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.y = 1.8; // Player height

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      // --- LIGHTING ---
      const ambientLight = new THREE.AmbientLight(0x606060, 1.2);
      scene.add(ambientLight);

      // Player flashlight
      const flashlight = new THREE.SpotLight(
        0xffffff,
        2,
        30,
        Math.PI / 6,
        0.5,
        1
      );
      flashlight.position.set(0, 0, 0);
      flashlight.castShadow = true;
      camera.add(flashlight);
      flashlight.target.position.set(0, 0, -1);
      camera.add(flashlight.target);

      // --- CONTROLS ---
      const controls = new PointerLockControls(camera, document.body);
      const blocker = document.getElementById("blocker");
      const instructions = document.getElementById("instructions");

      instructions.addEventListener("click", () => controls.lock());
      controls.addEventListener("lock", () => {
        instructions.style.display = "none";
        blocker.style.display = "none";
      });
      controls.addEventListener("unlock", () => {
        blocker.style.display = "block";
        instructions.style.display = "";
      });
      scene.add(controls.getObject());

      // --- PLAYER VARIABLES ---
      const playerVelocity = new THREE.Vector3();
      const playerDirection = new THREE.Vector3();
      const playerSpeed = 4.0;
      const playerSprintSpeed = 7.0;
      let isSprinting = false;
      let moveForward = false;
      let moveBackward = false;
      let moveLeft = false;
      let moveRight = false;
      const playerCollider = new THREE.Box3(
        new THREE.Vector3(),
        new THREE.Vector3()
      );
      playerCollider.setFromCenterAndSize(
        camera.position,
        new THREE.Vector3(0.5, 1.8, 0.5)
      );

      // --- KEYBOARD INPUT ---
      document.addEventListener("keydown", (event) => {
        switch (event.code) {
          case "ArrowUp":
          case "KeyW":
            moveForward = true;
            break;
          case "ArrowLeft":
          case "KeyA":
            moveLeft = true;
            break;
          case "ArrowDown":
          case "KeyS":
            moveBackward = true;
            break;
          case "ArrowRight":
          case "KeyD":
            moveRight = true;
            break;
          case "ShiftLeft":
            isSprinting = true;
            break;
          case "KeyR":
            if (isGameOver) location.reload();
            break;
        }
      });

      document.addEventListener("keyup", (event) => {
        switch (event.code) {
          case "ArrowUp":
          case "KeyW":
            moveForward = false;
            break;
          case "ArrowLeft":
          case "KeyA":
            moveLeft = false;
            break;
          case "ArrowDown":
          case "KeyS":
            moveBackward = false;
            break;
          case "ArrowRight":
          case "KeyD":
            moveRight = false;
            break;
          case "ShiftLeft":
            isSprinting = false;
            break;
        }
      });

      // --- MAZE GENERATION ---
      const maze = [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, "T", 1],
        [1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1],
        [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1],
        [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, "T", 0, 1, 0, 0, 0, 1, 0, 1],
        [1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
        [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, "T", 1, 1, 1, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, "T", 1, "P", 0, 0, 1],
        [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1],
        [1, "T", 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      ];

      const wallSize = 4;
      const wallHeight = 5;
      const wallMaterial = new THREE.MeshStandardMaterial({
        color: 0x666677,
        roughness: 0.8,
      });
      const floorMaterial = new THREE.MeshStandardMaterial({
        color: 0x444455,
        roughness: 0.9,
      });
      const walls = new THREE.Group();
      const terminals = [];
      const terminalSize = 0.5;

      const floor = new THREE.Mesh(
        new THREE.BoxGeometry(
          maze[0].length * wallSize,
          0.2,
          maze.length * wallSize
        ),
        floorMaterial
      );
      floor.position.y = -0.1;
      floor.receiveShadow = true;
      scene.add(floor);

      const ceiling = new THREE.Mesh(
        new THREE.BoxGeometry(
          maze[0].length * wallSize,
          0.2,
          maze.length * wallSize
        ),
        floorMaterial
      );
      ceiling.position.y = wallHeight;
      scene.add(ceiling);

      maze.forEach((row, z) => {
        row.forEach((cell, x) => {
          const posX = (x - Math.floor(row.length / 2)) * wallSize;
          const posZ = (z - Math.floor(maze.length / 2)) * wallSize;

          if (cell === 1) {
            const wall = new THREE.Mesh(
              new THREE.BoxGeometry(wallSize, wallHeight, wallSize),
              wallMaterial
            );
            wall.position.set(posX, wallHeight / 2, posZ);
            wall.castShadow = true;
            wall.receiveShadow = true;
            walls.add(wall);
          } else if (cell === "T") {
            const terminalGeo = new THREE.BoxGeometry(
              terminalSize,
              terminalSize,
              terminalSize
            );
            const terminalMat = new THREE.MeshBasicMaterial({
              color: 0x00ffff,
            });
            const terminal = new THREE.Mesh(terminalGeo, terminalMat);
            terminal.position.set(posX, wallHeight / 2, posZ);

            const terminalLight = new THREE.PointLight(0x00ffff, 2, 5);
            terminalLight.position.copy(terminal.position);
            scene.add(terminalLight);

            terminal.userData = { activated: false, light: terminalLight };
            terminals.push(terminal);
            scene.add(terminal);
          } else if (cell === "P") {
            controls.getObject().position.set(posX, 1.8, posZ);
          }
        });
      });
      scene.add(walls);

      // --- THE WARDEN (AI Hunter) ---
      const wardenGeo = new THREE.CapsuleGeometry(0.4, 2.5, 4, 16);
      const wardenMat = new THREE.MeshStandardMaterial({
        color: 0x1a1a1a,
        emissive: 0x000000,
        roughness: 0.2,
      });
      const warden = new THREE.Mesh(wardenGeo, wardenMat);
      warden.castShadow = true;
      warden.position.set(0, 1.65, 0);

      const wardenSensor = new THREE.PointLight(0x00ffff, 5, 15);
      wardenSensor.castShadow = true;
      wardenSensor.position.y = 1.0;
      warden.add(wardenSensor);
      scene.add(warden);

      let wardenState = "PATROL";
      const wardenSpeed = 1.5;
      const wardenHuntSpeed = 3.5;
      const wardenPath = [
        new THREE.Vector3(-28, 1.65, -24),
        new THREE.Vector3(28, 1.65, -24),
        new THREE.Vector3(28, 1.65, 24),
        new THREE.Vector3(0, 1.65, 0),
        new THREE.Vector3(-28, 1.65, 24),
      ];
      let currentPathIndex = 0;
      warden.position.copy(wardenPath[0]);
      const wardenRaycaster = new THREE.Raycaster();

      // --- THE RUNNER (Additional Running Enemy) ---
      const runnerTexture = new THREE.TextureLoader().load(
        "https://www.vhv.rs/dpng/d/485-4854988_running-sprite-sheet-png-graphic-transparent-stock-2d.png"
      );
      runnerTexture.magFilter = THREE.NearestFilter;
      runnerTexture.minFilter = THREE.NearestFilter;
      const runnerMaterial = new THREE.MeshBasicMaterial({
        map: runnerTexture,
        transparent: true,
        side: THREE.DoubleSide,
      });
      const runnerGeo = new THREE.PlaneGeometry(2, 3);
      const runner = new THREE.Mesh(runnerGeo, runnerMaterial);
      scene.add(runner);
      runner.position.set(10, 1.5, 10);

      let runnerState = "PATROL";
      const runnerSpeed = 2.5;
      const runnerHuntSpeed = 5.0;
      const runnerPath = [
        new THREE.Vector3(-10, 1.5, -10),
        new THREE.Vector3(10, 1.5, -10),
        new THREE.Vector3(10, 1.5, 10),
        new THREE.Vector3(-10, 1.5, 10),
      ];
      let currentPathIndexRunner = 0;
      runner.position.copy(runnerPath[0]);
      const runnerRaycaster = new THREE.Raycaster();
      let runnerFrame = 0;
      const numFrames = 10;
      const numRows = 6;

      const runnerSensor = new THREE.PointLight(0x00ffff, 5, 15);
      runnerSensor.castShadow = true;
      runnerSensor.position.y = 1.0;
      runner.add(runnerSensor);

      // --- SOUND DESIGN ---
      const listener = new THREE.AudioListener();
      camera.add(listener);

      const soundAmbiance = new THREE.Audio(listener);
      const soundHeartbeat = new THREE.Audio(listener);
      const soundStatic = new THREE.Audio(listener);

      const createTone = (context, frequency, duration, type = "sine") => {
        const oscillator = context.createOscillator();
        const gainNode = context.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(context.destination);
        oscillator.type = type;
        oscillator.frequency.value = frequency;
        gainNode.gain.setValueAtTime(0, context.currentTime);
        gainNode.gain.linearRampToValueAtTime(0.5, context.currentTime + 0.01);
        gainNode.gain.linearRampToValueAtTime(
          0,
          context.currentTime + duration
        );
        oscillator.start(context.currentTime);
        oscillator.stop(context.currentTime + duration);
      };

      const playHeartbeat = () => {
        const context = listener.context;
        createTone(context, 80, 0.1, "sine");
        setTimeout(() => createTone(context, 80, 0.1, "sine"), 150);
      };

      // --- GAME LOGIC ---
      let isGameOver = false;
      let terminalsActivated = 0;
      const clock = new THREE.Clock();

      function updateWarden(delta) {
        const playerPos = controls.getObject().position;
        const wardenPos = warden.position;
        const distanceToPlayer = wardenPos.distanceTo(playerPos);

        wardenRaycaster.set(
          wardenPos,
          playerPos.clone().sub(wardenPos).normalize()
        );
        const intersects = wardenRaycaster.intersectObjects(
          walls.children,
          false
        );
        const hasLineOfSight =
          intersects.length === 0 || intersects[0].distance > distanceToPlayer;

        if (hasLineOfSight && distanceToPlayer < 15) {
          if (wardenState !== "HUNT") {
            const context = listener.context;
            const bufferSize = context.sampleRate * 1;
            const buffer = context.createBuffer(
              1,
              bufferSize,
              context.sampleRate
            );
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
              data[i] = Math.random() * 2 - 1;
            }
            soundStatic.setBuffer(buffer);
            soundStatic.setVolume(0.3);
            soundStatic.play();
          }
          wardenState = "HUNT";
        } else if (distanceToPlayer > 30) {
          wardenState = "PATROL";
        }

        let target;
        let speed;

        if (wardenState === "HUNT") {
          target = playerPos;
          speed = wardenHuntSpeed;
          wardenSensor.color.set(0xff0000);
          wardenSensor.intensity = 10;
          warden.material.emissive.set(0x330000);

          const heartbeatSpeed =
            1.0 - THREE.MathUtils.clamp(distanceToPlayer / 20, 0, 1);
          const interval = 200 + (1 - heartbeatSpeed) * 800;
          if (!soundHeartbeat.isPlaying) {
            playHeartbeat();
            soundHeartbeat.source.buffer = null;
            soundHeartbeat.play();
            setTimeout(() => {
              if (soundHeartbeat.isPlaying) soundHeartbeat.stop();
            }, interval);
          }
        } else {
          target = wardenPath[currentPathIndex];
          speed = wardenSpeed;
          wardenSensor.color.set(0x00ffff);
          wardenSensor.intensity = 5;
          warden.material.emissive.set(0x000000);

          if (wardenPos.distanceTo(target) < 1) {
            currentPathIndex = (currentPathIndex + 1) % wardenPath.length;
          }
        }

        warden.lookAt(target.x, warden.position.y, target.z);
        warden.position.add(
          warden
            .getWorldDirection(new THREE.Vector3())
            .multiplyScalar(speed * delta)
        );

        if (distanceToPlayer < 1.0) {
          gameOver();
        }
      }

      function updateRunner(delta) {
        const playerPos = controls.getObject().position;
        const runnerPos = runner.position;
        const distanceToPlayer = runnerPos.distanceTo(playerPos);

        runnerRaycaster.set(
          runnerPos,
          playerPos.clone().sub(runnerPos).normalize()
        );
        const intersects = runnerRaycaster.intersectObjects(
          walls.children,
          false
        );
        const hasLineOfSight =
          intersects.length === 0 || intersects[0].distance > distanceToPlayer;

        if (hasLineOfSight && distanceToPlayer < 12) {
          runnerState = "HUNT";
        } else if (distanceToPlayer > 25) {
          runnerState = "PATROL";
        }

        let target;
        let speed;

        if (runnerState === "HUNT") {
          target = playerPos;
          speed = runnerHuntSpeed;
          runnerSensor.color.set(0xff0000);
          runnerSensor.intensity = 10;
        } else {
          target = runnerPath[currentPathIndexRunner];
          speed = runnerSpeed;
          runnerSensor.color.set(0x00ffff);
          runnerSensor.intensity = 5;

          if (runnerPos.distanceTo(target) < 1) {
            currentPathIndexRunner =
              (currentPathIndexRunner + 1) % runnerPath.length;
          }
        }

        runner.lookAt(camera.position);

        runner.position.add(
          runner
            .getWorldDirection(new THREE.Vector3())
            .multiplyScalar(speed * delta)
        );

        runnerMaterial.map.repeat.set(1 / numFrames, 1 / numRows);
        const frameRate = runnerState === "HUNT" ? 15 : 5;
        runnerFrame += delta * frameRate;
        const currentFrame = Math.floor(runnerFrame) % numFrames;
        const row = 0;
        runnerMaterial.map.offset.set(
          currentFrame / numFrames,
          (numRows - 1 - row) / numRows
        );

        if (distanceToPlayer < 1.0) {
          gameOver();
        }
      }

      function checkCollisions(delta) {
        const speed = isSprinting ? playerSprintSpeed : playerSpeed;
        playerVelocity.x -= playerVelocity.x * 10.0 * delta;
        playerVelocity.z -= playerVelocity.z * 10.0 * delta;

        // Calculate movement direction based on input
        let moveX = 0;
        let moveZ = 0;

        if (moveForward) moveZ -= 1;
        if (moveBackward) moveZ += 1;
        if (moveLeft) moveX -= 1;
        if (moveRight) moveX += 1;

        // Normalize diagonal movement
        if (moveX !== 0 || moveZ !== 0) {
          const length = Math.sqrt(moveX * moveX + moveZ * moveZ);
          moveX /= length;
          moveZ /= length;
        }

        // Apply movement to velocity
        playerVelocity.x += moveX * speed * delta * 10;
        playerVelocity.z += moveZ * speed * delta * 10;

        const oldPosition = controls.getObject().position.clone();

        // Apply movement using controls
        controls.moveForward(-playerVelocity.z * delta);
        controls.moveRight(playerVelocity.x * delta); // Remove the negative sign here

        playerCollider.setFromCenterAndSize(
          controls.getObject().position,
          new THREE.Vector3(0.5, 1.8, 0.5)
        );

        walls.children.forEach((wall) => {
          const wallBox = new THREE.Box3().setFromObject(wall);
          if (playerCollider.intersectsBox(wallBox)) {
            controls.getObject().position.copy(oldPosition);
            playerVelocity.set(0, 0, 0);
          }
        });
      }

      function checkInteractions() {
        const playerPos = controls.getObject().position;
        terminals.forEach((terminal) => {
          if (
            !terminal.userData.activated &&
            playerPos.distanceTo(terminal.position) < 3
          ) {
            terminal.userData.activated = true;
            terminalsActivated++;
            document.getElementById(
              "objective"
            ).innerText = `TERMINALS ACTIVATED: ${terminalsActivated}/5`;

            terminal.material.color.set(0x00ff00);
            terminal.userData.light.color.set(0x00ff00);

            const context = listener.context;
            createTone(context, 880, 0.1, "square");
            setTimeout(() => createTone(context, 1046, 0.2, "square"), 100);

            if (terminalsActivated === 5) {
              winGame();
            }
          }
        });
      }

      function gameOver() {
        if (isGameOver) return;
        isGameOver = true;
        controls.unlock();
        document.getElementById("game-over").style.display = "flex";
      }

      function winGame() {
        isGameOver = true;
        controls.unlock();
        const winScreen = document.getElementById("game-over");
        const winText = winScreen.querySelector(".game-over-text");
        winText.innerHTML = `<p style="color: #00ff00; text-shadow: 0 0 8px #00ff00;">> SYSTEM BYPASSED.</p><p style="color: #00ff00; text-shadow: 0 0 8px #00ff00;">> ESCAPE PROTOCOL ENGAGED.</p><br/><small>> YOU ARE FREE.</small>`;
        winScreen.style.display = "flex";
      }

      function animate() {
        if (isGameOver) return;

        requestAnimationFrame(animate);
        const delta = clock.getDelta();

        if (controls.isLocked === true) {
          checkCollisions(delta);
          checkInteractions();
          updateWarden(delta);
          updateRunner(delta);
        }

        renderer.render(scene, camera);
      }

      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
